# UdonSharp Unsupported Features & Workarounds (Unity 2022 / VRChat SDK 3.8.2)
# UdonSharp Unsupported Features & Workarounds (Unity 2022 / VRChat SDK 3.8.2)

## Overview of UdonSharp Limitations

UdonSharp compiles C# scripts to VRChat’s Udon assembly, but **not all standard C# and Unity features are supported**. Many classes, methods, and language features are *not exposed* in VRChat’s scripting sandbox. Below is a comprehensive list of features **UdonSharp does **not**** support, along with recommended alternatives. This knowledge is based on the current VRChat World SDK 3.8.2 (UdonSharp 1.x with Unity 2022) and will help you avoid using incompatible commands in your VRChat world scripts.

## Unsupported C# Language Features in UdonSharp

* **Custom Enums (historically unsupported, **now supported in U# 1.x**):** Older UdonSharp versions did not allow user-defined enums (only Unity’s built-in enums). As of UdonSharp 1.0, **user-defined `enum` types are supported** (and even can be synced in arrays). If you see outdated info saying enums aren’t allowed, note that this has been resolved – you can safely use `enum` types in the current SDK.
* **Generics in Classes/Collections:** UdonSharp **cannot use most generic types or generic classes**. For example, `List<T>` or `Dictionary<K,V>` from .NET will not compile (Udon does not support generic collections). **Use arrays** (`T[]`) or VRChat’s provided non-generic containers (like **DataList/DataDictionary**) instead. For instance, instead of `List<int>` use an `int[]` array, or use a `DataList` for dynamic lists. *(VRChat’s DataContainer classes are designed to work around the lack of generics.)* Likewise, you cannot define your own generic class `MyClass<T>` in U#, so design with specific types or arrays.
* **Interfaces:** UdonSharp **does not support C# interfaces** on your classes. You cannot `implement` an interface or call interface methods – this will fail to compile. **Workaround:** Use abstract base classes or design without interfaces. With UdonSharp 1.x you can use inheritance and virtual methods (see below) to achieve some of the same patterns, but true interfaces are not available.
* **Inheritance (now **supported** in U# 1.x):** Earlier UdonSharp did **not** allow inheriting custom classes (everything had to directly extend `UdonSharpBehaviour`). Now, UdonSharp 1.0 **supports class inheritance**, including virtual/override methods and even abstract classes. This means you *can* create a base `UdonSharpBehaviour` class and have others inherit from it for code reuse. **However, you still must ultimately inherit from `UdonSharpBehaviour`** (not `MonoBehaviour`) for any script used in a world. In practice, this means your class hierarchy’s root is `UdonSharpBehaviour`.
* **Method Overloading:** UdonSharp does **not support overloaded methods** (multiple methods with the same name but different parameters). All your method names in a class must be unique. **Workarounds:** Use different method names (e.g. `DoActionInt(int x)` vs `DoActionFloat(float y)` instead of overloading `DoAction`) or take advantage of default parameters (now allowed) to combine behaviors. *UdonSharp 1.x introduced support for default/optional parameters and `params` arrays, which often removes the need for overloads.*
* **Properties and Auto-Properties:** In older versions, user-defined C# properties (`public int Value { get; set; }`) were not supported. In U# 1.x, **auto-properties are now supported** as part of the compiler improvements. You may use them freely for cleaner code. If you encounter issues, the fallback is to use public fields or explicit getter/setter methods. *(Static properties remain unsupported – see static limitations below.)*
* **Delegates and Events:** You **cannot use C# delegates or events** in UdonSharp (they rely on .NET features not exposed in Udon). For example, defining an `event Action OnSomething;` or using lambda expressions/delegates will not compile. **Alternative:** Implement event systems manually – e.g. have a list of listener objects and call a method on each, or use Udon’s `SendCustomEvent` to trigger functions on other scripts. The Observer pattern must be done without C# events (e.g. via explicit method calls), since **delegates are not available**.
* **Exception Handling:** **Try/Catch/Finally blocks are not supported** in UdonSharp. You also **cannot throw exceptions** with `throw`. Any use of `try { ... } catch { ... }` or `throw new Exception()` will fail to compile. **Approach:** Design your code to avoid exceptions – use if/else checks to handle error conditions or return error codes. For example, instead of throwing an exception for invalid input, have your method return a boolean or special value to indicate failure. This way, you won’t need try/catch.
* **The `Awake()` Event:** Unity’s `Awake()` is **not called in UdonBehaviours** (Udon does not support the Awake event). If you write an `Awake()` method, it will be ignored. **Use `Start()` instead** for initialization logic that you would normally put in Awake. (Additionally, `OnEnable()` and `OnDisable()` *are* available in Udon, so those can be used for enable/disable events if needed – but Awake specifically is skipped in VRChat.)
* **`is` and `as` Type Casting:** The C# **`is` keyword is not supported** in UdonSharp for runtime type checks. Similarly, the **`as` cast is not supported**. This means you cannot do `if (obj is MyType) {...}` or `MyType x = obj as MyType`. **Workaround:** If you need to check type, compare `obj.GetType()` with the Type you expect (if the Type class is exposed), or structure your code to know the object’s type beforehand. Direct casts `(MyType)obj` *can* be used only if you are certain of the type (but note that a wrong cast will throw an exception at runtime which you can’t catch). In general, avoid dynamic type checking in Udon – design your program so you know what type you’re dealing with, or use separate UdonBehaviour scripts for different object types instead of one script handling multiple types.
* **Reflection and Dynamic Code:** **System.Reflection and dynamic code generation are not available.** You cannot introspect types or invoke methods by name at runtime. This isn’t explicitly a UdonSharp compiler error – rather, those .NET APIs are simply not whitelisted for use. Assume you can’t use `Type.GetType()`, `MethodInfo.Invoke`, dynamic `ExpandoObject`, etc. All behavior must be statically defined. There is no workaround in Udon for reflection – any such functionality must be implemented manually or avoided.
* **Multi-Dimensional Arrays:** UdonSharp **does not support multi-dimensional arrays** (e.g. `int[,] matrix`). Only one-dimensional *jagged* arrays (e.g. `int[][]`) are supported. If you need a 2D array, use an array of arrays (`int[][]`) instead of `int[,]`. Likewise, other multi-dimension declarations will not compile.
* **Jagged Array Quirks:** While jagged arrays are allowed, note that calling `.GetType()` on a jagged array may not return what you expect – UdonSharp may abstract it as `System.Object[]` for internal reasons. This usually isn’t a problem unless you rely on type reflection (which, as noted, isn’t supported anyway). Just be aware if debugging types.
* **Null-Conditional Operator:** The `?.` operator (null-conditional access) is **not supported** by UdonSharp’s compiler. For example, `myObject?.DoSomething()` will not compile. Replace such usage with explicit null checks:

  ```csharp
  if (myObject != null) { myObject.DoSomething(); }
  ```

  The null-coalescing operator `??` *is* supported in expressions, however (e.g. `x = value ?? defaultVal;` is allowed).
* **Goto and Labels:** **`goto` statements are not supported**, nor are labeled loops or statements. You’ll need to use structured loops (`break`/`continue` as needed) without goto jumps. This also means you cannot use labeled breaks outside of the normal loop scope. Redesign any logic that might use `goto` into structured loops or separate functions. (In practice, `goto` is rarely needed, so this limitation is usually not an issue.)
* **Object Initializer Syntax (in methods):** UdonSharp currently **cannot use object initializers inside functions** – for example, creating a new object with inline property setting:

  ```csharp
  // This will **not** compile in a method:
  var obj = new SomeClass() { field1 = 10, field2 = "Hi" };
  ```

  Such initializer syntax inside a method is not implemented. **Workaround:** Instantiate the object, then set properties in separate statements. (Notably, UdonSharp *does* allow initializer syntax for collections or objects **as field initializers** at the class level in some cases, just not within method bodies.)
* **Collection Initializers:** Similarly, you can’t use collection initializers in a method (e.g. `var arr = new int[] {1,2,3};` inside a function body might fail). Instead, declare the array and assign elements manually, or build it in a loop. (You *can* use array initializers at the point of declaration for fields or local variables, just not in all contexts inside methods due to compiler limitations – if you hit an error, assign elements one by one as a fallback.)
* **Default Value Expressions:** Prior to U# 1.x, the `default` literal for default values and default parameter values were not supported. UdonSharp 1.0 introduced support for default parameters and by extension the `default` keyword for those parameters. If you encounter issues, simply initialize variables to a specific default (e.g. use `0` instead of `default(int)`).
* **Partial Classes and Namespaces:** UdonSharp 1.x supports partial classes and all normal C# access modifiers for organizing code. One limitation to keep in mind is each UdonSharp script file can contain **only one class definition** (the class name must match the file name). You cannot define multiple classes in one .cs file as you might in standard C#. Also, **namespace alias directives and static `using` directives are not supported** – keep using statements simple. If you have naming conflicts, you may need to fully qualify names rather than relying on C# alias features.
* **Static Members:** UdonSharp has **limited support for static members**. **Static methods** are now supported in U# 1.0, but **static fields/properties are still not allowed** (they won’t compile). This means you cannot have a global static variable to share state; each Udon behaviour’s data must be in instance fields. *Workaround:* If you need a “global” value, you can designate a single object in the scene (singleton pattern) to hold that data in a non-static field, or use VRC world-defined variables/persistent variables for certain use cases. Similarly, static events/delegates (if they existed) wouldn’t work due to no delegates and no static fields.

## Unity API and Engine Limitations in VRChat Udon

* **MonoBehaviour vs UdonSharpBehaviour:** All UdonSharp scripts must inherit from `UdonSharpBehaviour` – do **not** use `MonoBehaviour` as a base class. Many MonoBehaviour-specific APIs are unavailable. For example, `gameObject.SendMessage()` and `StartCoroutine()` are part of MonoBehaviour and will not work on UdonSharpBehaviours. **Always subclass UdonSharpBehaviour.** The good news is UdonSharpBehaviour exposes most common Unity event methods (OnEnable, Update, etc.) so your script structure can be similar to MonoBehaviour aside from the unsupported features listed here.
* **Unity Event Functions (Lifecycle):** VRChat supports a subset of Unity’s event functions. Notably, `Awake()` is never called (use Start instead as mentioned), and `OnGUI` is not functional in VRChat (VRChat doesn’t run Unity’s IMGUI in worlds). **OnEnable/OnDisable, Start, Update, LateUpdate, FixedUpdate, OnDestroy, etc. are available** to override and will be called at appropriate times. (The VRChat SDK documentation provides a list of Unity events supported in Udon.) If a Unity message isn’t on that list, assume it won’t fire in VRChat. For example, mouse and keyboard event functions are not used in VRChat (see below).
* **User Input Handling:** **Do not use Unity’s `Input` class or OnMouse\* events** – these are not applicable in VRChat. VRChat runs in VR and desktop contexts with its own input system. **Instead, use VRChat’s input events and APIs:** e.g. use the `Interact()` event (override `public override void Interact()`) for when a user “uses” an object (like pressing E or triggering with VR controller). For VR controller inputs, Udon provides specific events such as `InputJump(bool value, UdonInputEventArgs args)`, `InputGrab/use`, etc., which correspond to VRChat input actions. The VRC SDK also provides static helpers in `VRC.SDKBase.InputManager` (e.g. `InputManager.GetLastUsedInputMethod()` to detect if the user is in VR or desktop). *OnMouseDown/OnMouseUp will not fire in VRChat world scripts*, and `Input.GetKey` etc. won’t return anything meaningful. Always rely on VRChat’s provided input events or UI interactions for user input.
* **Coroutines and Timing:** Unity’s coroutine system (`StartCoroutine`, `yield return new WaitForSeconds(...)`, etc.) **is not available in UdonSharp** – those are part of MonoBehaviour, which UdonBehaviours don’t use. **Use Udon’s event timing functions instead.** The most direct replacement is `SendCustomEventDelayedSeconds(string eventName, float delay, EventTiming timing)` which schedules one of your custom events to execute after a delay. For example, instead of starting a coroutine to wait 5 seconds, you would call `SendCustomEventDelayedSeconds("MyDelayedEvent", 5.0f, VRC.Udon.Common.Enums.EventTiming.Update);` and implement a public method `public void MyDelayedEvent() { ... }` for what should happen after the wait. Another approach is to use an `Update()` loop with a timer variable – e.g., set a float countdown and decrement it in Update until it reaches 0, then perform the action. **Do not attempt to use `Invoke()` or `InvokeRepeating`** (they are part of MonoBehaviour and not exposed). Leverage the Udon event system for any delayed or repeated execution.
* **Dynamic Object Instantiation/Destruction:** You generally **cannot instantiate or destroy GameObjects at runtime** in VRChat Udon. Functions like `GameObject.Instantiate()` or `Object.Destroy()` are **not exposed to Udon** (VRChat restricts these to maintain sync and security). All objects in your world are essentially those present in the scene or spawned via special SDK mechanisms. **Workarounds:** If you need “spawnable” objects, use the **VRC Object Pool** component to pre-create a pool of objects that can be enabled/disabled on demand, or use the **Player Objects** system (which can give each player a copy of a predefined object when they join). To simulate destroying an object, you can disable it (e.g., `gameObject.SetActive(false)`) or move it out of sight. To simulate spawning, design inactive objects or pooled objects that you activate when needed. *(The VRChat SDK’s Object Pool can be configured so you call `Networking.LocalPlayer.InitializePooling()` or similar to request an object from the pool rather than truly instantiating a new one.)* In short, **plan for a fixed set of objects** and manipulate their active state or position instead of creating/removing objects at will.
* **Unity UI Components:** Many built-in Unity UI classes are **not whitelisted for Udon**. For example, `UnityEngine.UI.Text`, `Image`, `Button`, etc. will cause errors like “type not supported” if you try to have them as variables or access them in Udon (as of this SDK). VRChat’s solution is to use **TextMeshPro for all text/UI**. The SDK provides a menu to create “TextMeshPro (VRChat)” canvases which automatically use TextMeshProUGUI and a `VRC_UIShape` for interaction. **Use `TMPro.TextMeshProUGUI` instead of `UI.Text`** – TextMeshPro components *are* exposed to Udon. Similarly, for UI Buttons and other interactable UI elements: add a **VRC\_UIShape** component to your Canvas so that VRChat’s cursor can interact with it. You can then handle UI button clicks by linking them to Udon events via the Unity Inspector (using Unity’s UI OnClick event to call an UdonBehaviour’s public method). *Note:* Some Unity UI events/delegates are stripped out by VRChat for security – only certain events like OnClick, OnValueChanged on allowed components will work. Check VRChat’s **UI Events allowlist** if you try to use more exotic UI events. In summary, **avoid UnityEngine.UI classes**; rely on TextMeshPro and VRC UI Shape for world UI.
* **Networking and External Data:** VRChat **sandboxes world scripts from arbitrary network or file access**. You **cannot use `System.IO`** to read or write files on the user’s machine, and **you cannot use `System.Net`/WebClient or direct HTTP requests** – those libraries are not available in Udon. The only way to get external data is via VRChat’s built-in mechanisms: for example, **String Loading** and **Image Loading** features. VRChat allows world scripts to request text from certain URLs using `VRCJson.JsonRequest` or `Networking.FetchString` (with user permission), and to display remote images or videos via `VRCUrl` assigned to components (like Video Players or Udon’s Image Loading system). But you cannot open random sockets or connect to arbitrary APIs from a world script. **Plan to either embed your data in the world or use the VRChat-provided limited web APIs**. Likewise, accessing local files or the filesystem is off-limits for world Udon scripts.
* **Threading and Async:** VRChat Udon runs on a single thread – there is **no multi-threading** support. You cannot create new Threads, use `Task.Run`, or `async/await` functionality. Any attempt to use `System.Threading` or `Task` libraries will either be blocked or simply never execute. All your code should be written to run in the one main thread (e.g., heavy computations should be spread across frames to avoid frame drops, since you can’t offload them to a background thread).
* **Physics and Collisions:** Basic physics functions (rigidbody movement, collisions, triggers) work in VRChat, but keep in mind **ownership and networking**: Only the owner of an object (usually the player who spawned or is holding it) can simulate its physics. Udon exposes calls like `VRCObjectSync` and networking to change ownership. The physics API (e.g. `Rigidbody.AddForce`) is available if the component is allowed, but make sure the object has **Ownership** by the local player when applying forces, otherwise it won’t move (or will snap back). This isn’t a limitation of UdonSharp per se, but a VRChat networking consideration – mention here because it “hinders” naive use of physics. Also, **character controllers and NavMesh agents** have limited support. VRChat recently added NavMesh components support for NPCs, but you must bake the navmesh beforehand (refer to VRChat “AI Navigation” docs if needed). In general, stick to whitelisted components (see VRChat’s Allowlisted World Components list) – if a component or its methods are not allowed, you’ll get a compile or runtime error.
* **Component Access and GetComponent:** Most common UnityEngine components are exposed to Udon, so `GetComponent<Transform>()` or `collider.gameObject` etc. will work. However, certain generic APIs have quirks – for example, **`GetComponent<UdonBehaviour>` is not directly exposed** (the generic version). If you need to get an UdonBehaviour (the raw Udon program component on an object), use the non-generic form and cast:

  ```csharp
  UdonBehaviour ub = (UdonBehaviour) GetComponent(typeof(UdonBehaviour));
  ```

  This is a known workaround. Similarly, if you have custom UdonSharpBehaviour subclasses and you want to get them via GetComponent, you can get the UdonBehaviour and then cast to your class if possible. Outside of UdonBehaviours, most Unity components can be fetched normally (e.g. `GetComponent<Rigidbody>()` works). If a component type isn’t exposed, the UdonSharp compiler will tell you. For example, trying `GetComponent<UnityEngine.UI.Text>()` would error since `UnityEngine.UI.Text` isn’t allowed – again, use TextMeshProUGUI in that case.
* **Synced Variables Limitations:** VRChat Udon allows syncing of certain variable types across the network (`[UdonSynced]` attribute). **Not all types can be synced.** You can sync basic types (int, float, bool), Vectors, Quaternions, and strings, as well as arrays of those and now user-enums, but you cannot sync complex types like GameObject or Component references directly. If you attempt to mark an unsupported type as synced, the compiler will error. Also, syncing of arrays is only supported in **Manual Sync mode** (one of VRChat’s sync settings) – in Automatic sync mode, array syncing won’t work properly. And certain types (like custom structs or classes) can’t be synced at all. Plan your networked variables around the supported types, and consider encoding complex data into syncable formats (for example, sync an `int` ID rather than a direct reference).
* **Miscellaneous Unity API Notes:** Some lesser-used Unity APIs are not present. For example, `Application.Quit()` is irrelevant in VRChat (worlds can’t quit the game), `SceneManager.LoadScene()` is not available (worlds can’t load other scenes arbitrarily), and `Resources.Load` is not exposed (worlds can’t load assets at runtime outside of what’s built in the scene). Audio playback is done via VRChat’s `VRC_SpatialAudioSource` or standard AudioSource (which is allowed), but you can’t use UnityWebRequest for audio – use `VRCUrl` on an AudioSource with an allowed URL. Particle Systems work, but you can’t instantiate them at runtime beyond what’s placed in the scene. **Always check VRChat’s official documentation or the UdonSharp “Class Exposure Tree”** if you’re unsure whether a Unity API is allowed – it will show in red if not exposed. In general, VRChat has whitelisted most of UnityEngine.Physics, Audio, Animator, etc., so basic game functionality is available. The biggest omissions to remember are anything dealing with external access (file, network), threading, or unsupported C# syntax as covered above.

## Conclusion and Best Practices

When coding in UdonSharp, keep these limitations in mind to avoid frustrating compile errors or non-functional code. Always inherit from **UdonSharpBehaviour**, and use the **VRChat SDK’s provided systems** (like Udon events, VRC components, and whitelisted APIs) for tasks that would normally rely on unsupported Unity features. If you attempt to use a method or type that “does not work with UdonSharp,” the compiler will usually tell you it’s not exposed or supported. Use those errors as guidance to refer back to this list and find the alternative approach (e.g. “Awake not supported – use Start”, “System.Math not working – use UnityEngine.Mathf functions with floats instead”). By following the supported patterns and workarounds outlined above, you’ll save time and avoid having to rewrite code that the VRChat platform can’t run. Happy scripting in VRChat!

**Sources:** VRChat UdonSharp Official Documentation and Community FAQs – these outline the unsupported features and recommended practices, as summarized and detailed above.

Resources:
https://creators.vrchat.com/worlds/udon/data-containers/data-dictionaries

https://vrclibrary.com/wiki/books/varneons-udonsharp-development-practices/

https://udonsharp.docs.vrchat.com/
